# 递归(recursion)思想

递归思想的核心就是把大问题拆解成小问题，小问题再去解决



核心：

1. 找出口：找到结束递归的标志或者叫方法（**一般都是到一个界限时结束**）
2. 找规律：将大问题拆解成有规律的一个一个的小问题
3. 

整体格式：

```java
public xxx fn(xx) {
  if(xx)... // 结束条件
  
  while(xx) {
    if(xx){
      // 走业务
    }else {
      // 走递归
      fn(xxx)
    }
  }
}
```





**找规律的技巧：**

首先，**我们先要确定函数的参数**，之后我们可以根据参数把每一个阶段的函数都写出来，然后用函数的方式表达出来

示例1：(递归求和的规律)

```java
// 求和1~100，那么我们参数传最大值100
// 规律：
Fn(100) = 100 + fn(99)
Fn(99) = 99 + fn(98)
Fn(98) = 98 + Fn(97)
...

// 出口
当i等于1时结束
Fn(1)
```



示例2：（阶乘的规律）

```java
// 求5的阶乘
//	规律
Fn(5) = 5 * Fn(4)
Fn(4) = 4 * Fn(3)
Fn(3) = 3 * Fn(2)
...

// 出口：
当i等于1时结束
Fn(1)
```



示例3：（斐波那契数列）

```java
// 1 1 2 3 5 8 ...
// 假如我们现在求到第10个数
Fn(10) = Fn(9) + Fn(8)
Fn(9) = Fn(8) + Fn(7)
...
    
// 规律
就是到1，和2结束
   
```







## 小练习

## 递归求和

需求：使用递归求1~100的和

代码示例：

```java
package test;

public class Test1 {
    public static void main(String[] args) {
        // 需求：使用递归求和 递归求1 ~ 100 的和

        System.out.println(sum(1));
    }

    // 我的方案
    public static int sum(int i) {
        if(i == 100) {
            return 100;
        }
//        i++; // 我这里写的就有问题，应该把i++丢进形参中去变化
//        return i + sum(i);


        // 正确写法
         return i + sum(i + 1);
    }


    // 老师方案
    public static int getSum(int number) {
        if(number == 1) {
            return 1;
        }

        // 如果number不是1时
        // 细节，就是把每次递归值的变化，放到参数里传递下去而不是放到函数体中
        return number + getSum(number - 1);
    }
}
```





## 递归求阶乘

需求：使用递归求5的阶乘

>tips:
>
>5的阶乘 = 5 * 4 * 3 * 2 * 1



代码示例：

```java
package test;

public class Test2 {
    public static void main(String[] args) {

        // 需求：使用递归求5的阶乘，

        // 5! = 5 * 4 * 3 * 2 * 1
        // 1.找出口：当数字为1时结束
        // 2.找规律： 5 * （4 * （3 * （2 * 1）））
      	// 5! = 5 * 4!
      	// 4! = 4 * 3!
      	// 3! = 3 * 2!s
      	// 2! = 2 * 1!
      	// 1! = 1 // 结束
      	


        System.out.println(getFactorial(5));
    }

    public static int getFactorial(int n) {
        if(n == 1) {
            return 1;
        }
				
      	// 把递归条件的变化放到参数中(●'◡'●)
        return n * getFactorial(n - 1);
    }
}
```







## 斐波那契数列、无尽兔子数学问题

代码：

```java
package test;

public class Test1 {
    public static void main(String[] args) {
        // 不死神兔子
        // 有一对兔子，从出生到第三个月后每个月都生一对小兔子，小兔子涨到三个月后每个月又可以生一对兔子，假设兔子都不死，12个月兔子有多少对？

        /**
         * 上面这个问题其实就是斐波那契数列
         * 1月：1
         * 2月：1
         * 三月：2
         * 4月：3
         * 五月：5
         * 六月：8
         * .。。
         *
         * 从第三个数字开始，就是前两个数字之和
         */

        // 方式一：利用数组解决，创建一个长度位12的数组，前两个值位1，然后从索引2开始计算

        int[] arr = new int[12];
        arr[0] = 1;
        arr[1] = 1;

        // 从2开始循环
        for (int i = 2; i < arr.length; i++) {
            // 前两个数之和
            arr[i] = arr[i - 1] + arr[i - 2];
        }

        printArr(arr);



        // 方式二：使用递归方式开始计算
        /*
            递归的核心：
            1.找出口
            2.找规律

            规律；
            假如12是i 那么后面就是 i-1 + i-2
            Fn(12) = Fn(11) + Fn(10)
            Fn(11) = Fn(10) + Fn(9)
            ...


            出口？
            由于第三个月开始是前两个数字之和，所以我们直接加到fn(2)和fn(1)结束即可(结束时，将Fn(1)和Fn(2)的数字1返回)
         */
        System.out.println("递归---------------------------");
        System.out.println(Fn(12));
    }


    public static void printArr(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i] + " ");
        }
    }


    // 斐波那契递归
    public static int Fn(int i) {

        // 等于1或2时都要结束
        if(i == 2 || i == 1) {
            // Fn(1) + Fn(2) 刚好就是2
            return 1;
        }

        // 下面规律相加
        return Fn(i - 1) + Fn(i - 2);
    }
}

```







## 猴子吃桃桃问题(反向递归)

代码：

```java
package test;

public class Test2 {
    public static void main(String[] args) {
        // 猴子吃桃问题

        // 有一堆桃子，猴子第一天吃了其中的一半，并且多吃了一个。以后每天猴子都吃当前剩下来的一半，再多吃一个，第10天时（还没吃），发现只剩下一个桃子了，请问最初总共有多少桃子？



        /*
            先考虑参数
            肯定传天数，不用想的
            规律：
            Fn(10) = Fn(9) / 2 - 1;
            Fn(9) = Fn(8) / 2 - 1;

            由于我们要求综合，所以得倒着lai（这个规律不太对，如果这个规律就是先多吃一个，再去吃剩下的一半）
            Fn(1) = Fn(2) * 2 + 1;
            Fn(2) = Fn(3) * 2 + 1;
            Fn(3) = Fn(4) * 2 + 1;

            或者这样的规律（这个规律是，先吃一般再多吃一个，所以说这个规律才是对的）
            Fn(1) = (Fn(2) + 1) * 2;
            Fn(2) = (Fn(3) + 1) * 2;
            ....
            出口
            // 题目上已经提示第十天，还有最后1个
            Fn(10) = 1;
         */

        System.out.println(Fn(1));
    }


    public static int Fn(int day) {
        if(day == 10) {
            return 1;
        }

        return (Fn(day + 1) + 1) * 2;
    }
}

```



## 小明爬楼梯

代码：

```java
package test;

public class Test3 {
    public static void main(String[] args) {
        // 可爱的小明喜欢爬楼梯，他有的时候一次爬一个台阶，有时候一次爬两个台阶，如果这个楼梯有20个台阶，小明一共有多少种爬法？

        /*
            运算结果：
            1层台阶 1种爬法
            2层台阶 2种爬法
            3层台阶 3种爬法
            4层台阶 5种爬法
            5层台阶 8种爬法
            6层台阶
            7层台阶 21种爬法

            后续看起来其实就是一个类似斐波那契数列的感觉，当前值时前两个值相加，从第三个开始
        */


        /*
            找规律:
            Fn(20) = Fn(19) + Fn(18)
         */


        System.out.println(Fn(20));
    }


    public static int Fn(int n) {
        if(n == 1) {
            return 1;
        }

        if(n == 2) {
            return 2;
        }

        return  Fn(n - 1) + Fn(n - 2);
    }
}

```

