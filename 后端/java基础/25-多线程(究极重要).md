# 多线程



## 线程

线程：线程是操作系统能够进行运算的调度的最小单位。它被包含在**进程**之中，是进程中的实际运作单位。



### 进程和线程【理解】

- 进程：是正在运行的程序

  独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位
  动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的
  并发性：任何进程都可以同其他进程一起并发执行

  

- 线程：是进程中的单个顺序控制流，是一条执行路径

  单线程：一个进程如果只有一条执行路径，则称为单线程程序

  **多线程**：一个进程如果有多条执行路径，则称为多线程程序



简单理解一下：

![25-进程和线程理解](./imgs/25-进程和线程理解.png)

从上面示例图中，我们可以把**360软件运行**这个看作是一个进程，然后里面**木马查杀、电脑清理、系统修复、优化加速**等，看作是线程

### 并发和并行【理解】

+ 并行：在同一时刻，有多个指令在多个CPU上**同时执行**。


![25-并行](./imgs/25-并行.png)

+ 并发：在同一时刻，有多个指令在单个CPU上**交替执行**。

![25-并发](./imgs/25-并发.png)





## 多线程实现方式

### 实现多线程方式一：继承Thread类【应用】

- 方法介绍

  | 方法名       | 说明                                        |
  | ------------ | ------------------------------------------- |
  | void run()   | 在线程开启后，此方法将被调用执行            |
  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |

- 实现步骤

  - 定义一个类MyThread继承Thread类
  - 在MyThread类中重写run()方法
  - 创建MyThread类的对象
  - 启动线程

- 代码演示

  ```java
  package a01threadadcases1;
  
  public class ThreadDemo1 {
      public static void main(String[] args) {
          /*
              多线程的第一种启动方式
  
              1.定义子类继承Thread类
              2.重写父类Thread类中的run方法
              3.创建子类对象，启动线程
           */
  
  
          // 1.创建子类对象
          MyThread mt1 = new MyThread();
          MyThread mt2 = new MyThread();
  
          // 给线程起个名字
          mt1.setName("线程1");
          mt2.setName("线程2");
  
  
          // 2.start方法来开启线程（JVM会调用run方法）
          mt1.start();
          mt2.start();
      }
  }
  
  ```

- 两个小问题

  - 为什么要重写run()方法？

    因为run()是用来封装被线程执行的代码

  - run()方法和start()方法的区别？

    run()：封装线程执行的代码，直接调用，相当于普通方法的调用

    start()：启动线程；然后由JVM调用此线程的run()方法



### 实现多线程方式二：实现Runnable接口【应用】

我们可以简单理解：把实现`Runnable`接口类创建的实例对象，当作是一个任务，将要下发给一个线程，这个线程需要你自己`new Thread`来创建



- Thread构造方法

  | 方法名                               | 说明                   |
  | ------------------------------------ | ---------------------- |
  | Thread(Runnable target)              | 分配一个新的Thread对象 |
  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |

- 实现步骤

  - 定义一个类MyRunnable实现Runnable接口
  - 在MyRunnable类中重写run()方法
  - 创建MyRunnable类的对象
  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数
  - 启动线程

- 代码演示

  ```java
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          for(int i=0; i<100; i++) {
            	// Thread.currentThread()获取当前正在运行的线程对象
              System.out.println(Thread.currentThread().getName()+":"+i);
          }
      }
  }
  public class MyRunnableDemo {
      public static void main(String[] args) {
          //创建MyRunnable类的对象
          MyRunnable my = new MyRunnable();
  
          //创建Thread类的对象，把MyRunnable对象作为构造方法的参数
          //Thread(Runnable target)
  //        Thread t1 = new Thread(my);
  //        Thread t2 = new Thread(my);
        	// t1.setName("线程1");
          //Thread(Runnable target, String name)
          Thread t1 = new Thread(my,"坦克");
          Thread t2 = new Thread(my,"飞机");
  
          //启动线程
          t1.start();
          t2.start();
      }
  }
  ```



### 实现多线程方式三: 实现Callable接口【应用】

方法介绍

| 方法名                             | 说明                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| V call()                           | 计算结果，如果无法计算结果，则抛出一个异常           |
| `FutureTask`(Callable<V> callable) | 创建一个 `FutureTask`，一旦运行就执行给定的 Callable |
| V get()                            | 如有必要，等待计算完成，然后获取其结果               |



**特点：**

能够获取到多线程运行的结果



实现步骤

+ 定义一个类MyCallable实现Callable接口
+ 在MyCallable类中重写call()方法(call方法有返回值，表示运行结果)
+ 创建MyCallable类的对象（表示多线程要执行的结果）
+ 创建Future的实现类`FutureTask`对象，把MyCallable对象作为构造方法的参数（作用管理多线程运行的结果）
+ 创建Thread类的对象，把`FutureTask`对象作为构造方法的参数
+ 启动线程
+ 再调用get方法，就可以获取线程结束之后的结果。

+ 代码演示

  ```java
  
  // 这里Callable后面的泛型，就代表着运行返回结果的类型
  public class MyCallable implements Callable<String> {
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 100; i++) {
              System.out.println("跟女孩表白" + i);
          }
          //返回值就表示线程运行完毕之后的结果
          return "答应";
      }
  }
  
  
  public class Demo {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          //线程开启之后需要执行里面的call方法
          MyCallable mc = new MyCallable();
  
          //Thread t1 = new Thread(mc);
  
          //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象
          FutureTask<String> ft = new FutureTask<>(mc);
  
          //创建线程对象
          Thread t1 = new Thread(ft);
  
          String s = ft.get();
          //开启线程
          t1.start();
  
          //String s = ft.get();
          System.out.println(s);
      }
  }
  ```

  

### 三种实现方式的对比

**对比一：**

实现Runnable、Callable接口

+ 好处: 扩展性强，实现该接口的同时还可以继承其他的类
+ 缺点: 编程相对复杂，不能直接使用Thread类中的方法

继承Thread类

+ 好处: 编程比较简单，可以直接使用Thread类中的方法
+ 缺点: 可以扩展性较差，不能再继承其他的类



**对比二：**

* 继承`Thread`类和实现`Runnable`接口，都不能获取多线程运行的结果
* 实现`Callable`接口，是可以获取多线程执行的结果



## Thread常见的成员方法

![25-Thread类成员方法](./imgs/25-Thread类成员方法.jpg)

### 设置和获取线程名称

方法介绍

| 方法名                           | 说明                               |
| -------------------------------- | ---------------------------------- |
| `void  setName(String name)`     | 将此线程的名称更改为等于参数name   |
| `String  getName()`              | 返回此线程的名称                   |
| `static Thread  currentThread()` | 返回对当前正在执行的线程对象的引用 |

小细节：

1. 如果没有调用`setName`给线程设置名字，会有默认名字`Thread-X`(`x`从0开始的序号，例如：Thread-0)
2. 当`JVM`虚拟机启动后，会自动启动多条线程，其中有一条线程叫做main





代码演示

```java
public class MyThread extends Thread {
    public MyThread() {}
    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName()+":"+i);
        }
    }
}
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

        //void setName(String name)：将此线程的名称更改为等于参数 name
        my1.setName("高铁");
        my2.setName("飞机");

        //Thread(String name)
        MyThread my1 = new MyThread("高铁");
        MyThread my2 = new MyThread("飞机");

        my1.start();
        my2.start();

        //static Thread currentThread() 返回对当前正在执行的线程对象的引用
        System.out.println(Thread.currentThread().getName());
    }
}
```

### 线程休眠

相关方法

| 方法名                         | 说明                                             |
| ------------------------------ | ------------------------------------------------ |
| static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |



小细节：

1. 那条线程执行到这个方法，那个线程就会休眠(停顿)对应时间
2. 当休眠时间到达之后，该线程会**自动苏醒并执行后续代码**





代码演示

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "---" + i);
        }
    }
}
public class Demo {
    public static void main(String[] args) throws InterruptedException {
        /*System.out.println("睡觉前");
        Thread.sleep(3000);
        System.out.println("睡醒了");*/

        MyRunnable mr = new MyRunnable();

        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);

        t1.start();
        t2.start();
    }
}
```





### 线程优先级

线程调度

- 两种调度方式

  - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
  - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

- Java使用的是**抢占式调度模型**

- **随机性**

  假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

  

优先级相关方法

| 方法名                                    | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| `final int getPriority()`                 | 返回此线程的优先级                                           |
| `final void setPriority(int newPriority)` | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |

代码演示

```java
package a04threadmethod2.a04threadmethod;

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i <= 1000; i++) {
            System.out.println(getName() + "线程执行中" + i);
        }
    }
}


package a04threadmethod2.a04threadmethod;

public class ThreadDemo {
    public static void main(String[] args) throws InterruptedException {
      
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        t1.setName("小狗");
        t2.setName("小猫");

        // 设置优先级
        t1.setPriority(5);
        t2.setPriority(10); // 优先级越高，说明能抢占到CPU的概率越高

        t1.start();
        t2.start();

        System.out.println("小狗线程优先级" + t1.getPriority());
        System.out.println("小猫线程优先级" + t2.getPriority());
//
//
//        // main线程的优先级也是默认值5
//        System.out.println(Thread.currentThread().getPriority());
    }
}

```

### 守护线程

相关方法

| 方法名                       | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| `void setDaemon(boolean on)` | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |

通俗易懂：

**当非守护线程执行完毕后，守护线程也会结束**



代码演示

```java
public class MyThread1 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName() + "---" + i);
        }
    }
}
public class MyThread2 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "---" + i);
        }
    }
}
public class Demo {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        MyThread2 t2 = new MyThread2();

        t1.setName("女神");
        t2.setName("备胎");

        //把第二个线程设置为守护线程
        //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.
        t2.setDaemon(true);

        t1.start();
        t2.start();
    }
}
```





### 出让线程/插入线程

相关方法

| 方法名                     | 说明     |
| -------------------------- | -------- |
| `public static void yield` | 出让线程 |
| `public final void join`   | 插入线程 |



出让线程`yield`方法代码示例：

```java
package a06threadmethod;

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            System.out.println(getName() + "@" + i);
            Thread.yield(); // 出让当前CPU执行权（线程执行到此后，就会将CPU让给别人）
        }
    }
}





package a06threadmethod;

public class ThreadDemo {
    public static void main(String[] args) {

        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();


        t1.setName("小狗");
        t2.setName("小猫");

        t1.start();
        t2.start();
    }
}

```



插入线程`join`方法示例代码：

```java
package a07threadmethod;

public class ThreadDemo {
    public static void main(String[] args) throws InterruptedException {

        MyThread t = new MyThread(); // MyThread类和上面yield方法的一致
        t.setName("小狗");
        t.start();

        // 表示把t插入到当前线程之前（当前线程就是main因为main线程中运行的t.join）
        t.join();
        // 结果：t线程会先执行完毕，之后main中的线程才执行完


        // 以下代码执行在main线程中
        for (int i = 0; i < 10; i++) {
            System.out.println("main线程" + i);
        }
    }
}

```





## 线程的生命周期

流程图：

![25-线程的生命周期](./imgs/25-线程的生命周期.png)





## 线程的安全问题

线程在执行时，它并不一定能将代码执行完，而是随机被抢走执行权，这就会导致一些数据问题（执行顺序有问题）





## 2.线程同步

### 2.1卖票【应用】

案例需求

某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票



核心：

就是将三个窗口，我们看作是三个线程，我们直接创建三个线程出来帮我们买票即可



代码实现：

```java
package test1;

public class MyThread extends Thread{


    private static int ticked = 0; // 0~99

    // 锁对象：一定保证要是唯一的(我们用static修饰以下，就能做到，无论多少个MyThread实例，都用的同一个obj)_
    private static Object obj = new Object();


    @Override
    public void run () {
        while (true) {
            if(ticked < 100) {
                try {
                    Thread.sleep(100);
                    ticked++;
                    System.out.println(getName() + "正在卖第" + ticked + "张票");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                break;
            }
        }
    }
}




public class SellTicketDemo {
    public static void main(String[] args) {
        //创建SellTicket类的对象
        SellTicket st = new SellTicket();

        //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
        Thread t1 = new Thread(st,"窗口1");
        Thread t2 = new Thread(st,"窗口2");
        Thread t3 = new Thread(st,"窗口3");

        //启动线程
        t1.start();
        t2.start();
        t3.start();
    }
}
```


### 2.2卖票案例的问题【理解】

卖票出现了问题

- 相同的票出现了多次

- 还会出现额外的票（例如101，102等）

问题产生原因

* 线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题




### 2.3同步代码块解决数据安全问题【应用】

安全问题出现的条件

- 是多线程环境

- 有共享数据

- 有多条语句操作共享数据



如何解决多线程安全问题呢?

- 基本思想：让程序没有安全问题的环境



怎么实现呢?

- 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

- Java提供了同步代码块的方式来解决



同步代码块格式：

```java
// 注意：任意对象一定要保持唯一
synchronized(任意对象) { 
	//多条语句操作共享数据的代码 
}
```

`synchronized(任意对象)`：就相当于给代码加锁了，任意对象就可以看成是一把锁（**任意对象一定要唯一！！！**）

>tips：
>
>为什么任意对象一定要唯一？
>
>首先上面说了，任意对象相当于是一把锁，假如线程1过来，看的锁(任意对象)，线程2再过来时，看到的是另外一把锁(任意对象)，那么这个锁还有意义嘛？锁不住啊



**特点：**

1. 锁默认打开，有一个线程进入后，自动关闭
2. 里面代码执行完毕后，线程出来，锁自动打开





同步的好处和弊端  

- 好处：解决了多线程的数据安全问题

- 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是**很耗费资源的**，无形中会降低程序的运行效率



代码演示

```java
package test1;

public class MyThread extends Thread{


    private static int ticked = 0; // 0~99

    // 锁对象：一定保证要是唯一的(我们用static修饰以下，就能做到，无论多少个MyThread实例，都用的同一个obj)
    private static Object obj = new Object();


    @Override
    public void run () {
        while (true) {

            // 同步代码块
          	// 锁住后，代码块里的代码，在执行时资源不会被抢走
          	// 通常这样写synchronized(MyThread.class) 当前文件的这个class对象肯定是唯一的
            synchronized (obj) {
                if(ticked < 100) {
                    try {
                        Thread.sleep(100);
                        ticked++;
                        System.out.println(getName() + "正在卖第" + ticked + "张票");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    break;
                }
            }
        }
    }
}

```

### 2.4同步方法解决数据安全问题【应用】

**同步方法**的格式：

就是把synchronized关键字加到方法上

```java
修饰符 synchronized 返回值类型 方法名(方法参数) { 
	方法体；
}
```



**特点：**

1. 同步方法是锁住方法里面所有的代码块
2. 锁对象不能自己指定

>tips：
>
>同步方法中，锁对象，Java会自己指定
>
>非静态方法：this
>
>静态方法：当前类的字节码文件对象(文件名/类名.class)



静态同步方法

同步静态方法：就是把synchronized关键字加到静态方法上

```java
修饰符 static synchronized 返回值类型 方法名(方法参数) { 
	方法体；
}
```





代码示例：（还是上面那个卖票的案例）

```java

```









### 2.5Lock锁【应用】

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化

ReentrantLock构造方法

| 方法名          | 说明                        |
| --------------- | --------------------------- |
| ReentrantLock() | 创建一个ReentrantLock的实例 |



加锁解锁方法

| 方法名        | 说明   |
| ------------- | ------ |
| void lock()   | 获得锁 |
| void unlock() | 释放锁 |

代码演示

  ```java

  public class Ticket implements Runnable {
      //票的数量
      private int ticket = 100;
      private Object obj = new Object();
      private ReentrantLock lock = new ReentrantLock();

      @Override
      public void run() {
          while (true) {
              //synchronized (obj){//多个线程必须使用同一把锁.
              try {
                  lock.lock();
                  if (ticket <= 0) {
                      //卖完了
                      break;
                  } else {
                      Thread.sleep(100);
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
              // }
          }
      }
  }

  public class Demo {
      public static void main(String[] args) {
          Ticket ticket = new Ticket();

          Thread t1 = new Thread(ticket);
          Thread t2 = new Thread(ticket);
          Thread t3 = new Thread(ticket);

          t1.setName("窗口一");
          t2.setName("窗口二");
          t3.setName("窗口三");

          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```





### 2.6死锁【理解】

+ 概述

  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

+ 什么情况下会产生死锁

  1. 资源有限
  2. 同步嵌套

+ 代码演示

  ```java
  public class Demo {
      public static void main(String[] args) {
          Object objA = new Object();
          Object objB = new Object();
  
          new Thread(()->{
              while(true){
                  synchronized (objA){
                      //线程一
                      synchronized (objB){
                          System.out.println("小康同学正在走路");
                      }
                  }
              }
          }).start();
  
          new Thread(()->{
              while(true){
                  synchronized (objB){
                      //线程二
                      synchronized (objA){
                          System.out.println("小薇同学正在走路");
                      }
                  }
              }
          }).start();
      }
  }
  ```

## 