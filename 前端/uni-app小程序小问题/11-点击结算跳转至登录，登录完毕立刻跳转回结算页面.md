# 点击结算跳转至登录，登录完毕立刻跳转回结算页面



核心思路：我们在点击结算时，需要将跳转的信息（`userInfo`）保存一份到`vuex`中，等登录完毕后，再根据`vuex`中保存的`userInfo`信息，跳转回结算界面。



代码：

vuex：

```js
// 这里vuex只写了和该案例有关的东西
export default {
  namespaced: true,
  state: () => ({
   // 重定向对象： {opentype: 跳转类型是跳转navigate还是switchBar from: 从哪里跳转过来的}
   redirectInfo: null
  }),
  mutations: {
    // 更新重定向对象
    updateRedirectInfo(state, info) {
      state.redirectInfo = info
      console.log(state.redirectInfo)
    }
  }
}
```



结算页面：

```vue
<template>
  <view class="my-settle-container">
    <!-- 结算 -->
    <view @click="settlement" class="btn-settle">
      结算({{checkedCount}})
    </view>
  </view>
</template>

<script>
  import {mapState,mapGetters,mapMutations} from 'vuex';
  export default {
    name:"my-settle",
    data() {
      return {
        // 倒计时秒数
        second: 3,
        // 定时器
        timer: null
      };
    },
    computed: {
      ...mapGetters('m_cart', ['checkedCount', 'total','checkedGoodsAmount']),
      ...mapState('m_user', ['token']),
    },
    methods: {
      ...mapMutations('m_user', ['updateRedirectInfo']),
      // 用户点击结算按钮
      settlement() {
        // 1.判断用户是否选择商品，商品数
        if(!this.checkedCount) return uni.$showMsg('请选择要结算的商品');
        
        // 2.判断用户是否选择收获地址
        if(!this.addstr) return uni.$showMsg('请选择收获地址');
        
        // 3.判断用户是否登录，判断token，如果用户没有登录，3秒后跳转到我的，登录界面
        if(!this.token) {
          this.delayNavigate();
        };
        
      },
      // 展示倒计时提示消息
      showTips(n) {
        uni.showToast({
          icon:'none',
          title: '请登陆后再结算!' + n + '秒之后跳转到登录页。',
          mask: true, // 防止点击穿透，就是展示提示时，点击不了
          duration: 1500
        })
      },
      // 延时导航到我的页面，让用户去登录
      delayNavigate() {
        // 每次调用这个方法时，就重置一下second
        this.second = 3;
        this.showTips(this.second);
        // 开启一个定时器，每过1s就减少一下second，并再次调用showTips
        this.timer = setInterval(() => {
          this.second--;
          if(this.second <= 0) {
            clearInterval(this.timer);
            
            // 核心在这里！！！！！！！！！（该案例的核心）
            uni.switchTab({
              url: '/pages/my/my',
              success: () => { // 这里要写成箭头函数，防止里面的this指向问题
                // 调用mutation方法，更新保存一下跳转的信息
                this.updateRedirectInfo({
                  openType: 'switchTab', // 跳转类型
                  from: '/pages/cart/cart' // 从哪里跳转的
                })
              }
            })
            return; // 直接return，就不会走下面的showTips了
          };
          this.showTips(this.second); 
        }, 1000)
      }
    }
  }
</script>

```



登录页面：

```vue
<template>
  <view class="login-container">
    <uni-icons type="contact-filled" size="100" color="#afafaf"></uni-icons>
    
    <button @click="getUserProfile" type="primary" class="btn-login">一键登录</button>
    
    <text class="tips-text">登陆后尽享更多权益</text>
  </view>
</template>

<script>
  import {mapMutations, mapState} from 'vuex'
  export default {
    name:"my-login",
    data() {
      return {
        
      };
    },
    computed: {
      ...mapState('m_user', ['redirectInfo'])
    },
    methods: {
      ...mapMutations('m_user', ['updateUserInfo', 'updateToken','updateRedirectInfo']),
      async getUserProfile() {
        const  [err, userInfo] =  await uni.getUserProfile({desc:'用户登录'}).catch(err => err);
        if(err?.errMsg === "getUserProfile:fail auth deny") return uni.$showMsg('您拒绝了授权');
        // 调用mutations方法，将用户信息存储到vuex中
        this.updateUserInfo(userInfo);
				
       	// 调用获取token的方法
        this.getToken(userInfo);
      },
      // 登录并获取token并存储token
      async getToken(info) {
        // 获取code对应的值
        const [err, res] = await uni.login().catch(err => err);
        // uni.login如果报错了，err就不是null了，直接报错
        if(err ||res.errMsg !== "login:ok") return uni.$showMsg('登录失败');
        
        // 准备接口参数
        const query = {
          code: res.code,
          encryptedData: info.encryptedData,
          rawData: info.rawData,
          iv: info.iv,
          signature: info.signature
        }
        // 发起登录请求
        // const {data: loginResult} = await uni.$http.post('/api/public/v1/users/wxlogin', query);
        // 目前接口有问题，我们就直接当登录成功了
        // console.log(loginResult);
        
        // 将token保存进vuex
        this.updateToken('Bearer');
        
        // 该案例的核心在这里！！！！！
        
        // 调用回退函数，回退到登录之前的页面（如果有的化）
        this.navigateBack()
      },
      // 核心函数，回退函数，根据保存的userInfo进行回退操作
      navigateBack() {
        if(this.redirectInfo && this.redirectInfo.openType === 'switchTab') {
          // 如果vuex中有redirectInfo且openType是switchTab
          uni.switchTab({
            url: this.redirectInfo.from,
            complete: ()=> {
              // 跳转完成之后，清空vuex中存储的redirectInfo
              this.updateRedirectInfo(null);
            }
          })
        }
      }
    }
  }
</script>

```



