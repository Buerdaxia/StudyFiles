# 迭代器和生成器

# 迭代器（iterator）

首先，为什么要出现迭代器？

原先JavaScript中的迭代机制出现的一些小问题：

1. **迭代之前需要事先知道如何使用数据结构**。数组中的每一项都只能先通过引用取得数组对象， 然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。
2.  **遍历顺序并不是数据结构固有的**。通过递增索引来访问数据是特定于数组类型的方式，并不适 用于其他具有隐式顺序的数据结构。



简单来说，迭代不仅仅只用在数组这样的数据结构中，而是更多其他数据结构中也能够进行迭代。

核心：**任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）**



迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的 值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。



## 可迭代协议

实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力。

在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而 且这个属性必须使用特殊的**Symbol.iterator**作为键。这个默认迭代器属性必须引用一个**迭代器工厂 函数**，调用这个工厂函数必须返回一个新迭代器。

原生就实现了Iterable接口的类型：

**Array, Arguments, Set, Map, String, TypedArray, NodeList**



如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口：

```js
class FooArray extends Array {}
let fooArr = new FooArray('foo', 'bar', 'baz');
for (let el of fooArr) {  
  console.log(el);
}
// foo  // bar  // baz
```



## 迭代器协议

迭代器是一个一次性使用的对象，用于迭代与其关联的可迭代对象。

迭代器 API 使用**next()**方法 在可迭代对象中遍历数据，每次成功调用 next()，都会返回一个**IteratorResult**对象，其中包含迭 代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。

`IteratorResult`对象：

```js
{
  value:'',
  done: true // true或者false
}
```

next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布 尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为 false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。



示例：

```js
// 可迭代对象
let arr = ['foo', 'bar']; 

// 迭代器
let iter = arr[Symbol.iterator]();

// 执行迭代
console.log(iter.next()); // { done: false, value: 'foo' } 
console.log(iter.next()); // { done: false, value: 'bar' } 
console.log(iter.next()); // { done: true, value: undefined } 
```

这里，通过迭代器调用next()方法，按顺序迭代了数组，直至不再产生新值。





## 总结

可迭代的数据结构身上都会实现一个属性叫做`[Symbol.iterator]`，该属性的键值为一个迭代器工厂函数。调用后会返回一个**迭代器**

一：**迭代器**上拥有一个叫做`next()`的API，每次调用都会返回一个`IteratorResult`对象，每次调用`next()`函数就会返回一个新的`IteratorResult`，其中done属性标识着这个迭代器是否迭代结束。

>注意：当done值等于true时，任然可以重复调用next()会返一个value: undefined，done: true的`IteratorResult`对象

```js
// IteratorResult
{
  value: 'xxx',
  done: true/false // true代表结束，false代表还没迭代结束
}
```





二：迭代器互相之间互不干扰，每个迭代器都仅仅通过自己的`next()`方法来确认自己的”迭代位置“

示例：

```js
let arr = [1, 2, 3];
let iter1 = arr[Symbol.iterator]();
let iter2 = arr[Symbol.iterator]();

iter1.next(); // {value: 1, done: false}
iter1.next(); // {value: 2, done: false}
// 两个迭代器之间互相不干扰
iter2.next();// {value: 1, done: false}
```



三：迭代器是允许提前终止的，可选的return() 方法用于在指定的迭代器中，来终止迭代，不想让它迭代到对象小号完毕

例如：

*  for-of 循环通过 break、continue、return 或 throw 提前退出；
*  解构操作并未消费所有值。

这些都是提前暂停迭代。



如果一个迭代器没有关闭，例如数组（数组的迭代是不允许被关闭的），它还是会从上次位置进行迭代：

>注意：因为 return()方法是可选的，所以并非所有迭代器都是可关闭的

示例：

```js
et a = [1, 2, 3, 4, 5]; 
let iter = a[Symbol.iterator](); 
for (let i of iter) { 
 console.log(i); 
 if (i > 2) { 
 break 
 } 
} 
// 1 
// 2 
// 3 
for (let i of iter) { 
 console.log(i); 
} 
// 4 
// 5 
```





# 生成器

生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的 能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。



语法：

```js
// 生成器函数声明
function* generatorFn() {} 
// 生成器函数表达式
let generatorFn = function* () {} 
// 作为对象字面量方法的生成器函数
let foo = { 
 * generatorFn() {} 
} 
// 作为类实例方法的生成器函数
class Foo { 
 * generatorFn() {} 
} 
// 作为类静态方法的生成器函数
class Bar { 
 static * generatorFn() {} 
}
```

>注意：箭头函数不能用来定义生成器函数
