# 对象

多个数据的封装体，用来保存多个数据的容器，一个对象也能表示现实中的一个事务。

语法： var obj = {

​	name: '钱不二',

​	age: 22,

​	gender: "男"

}

## 对象的组成

* 属性：代表现实事物的状态数据==>属性名(字符串)和属性值(任意类型)组成
* 方法：代表现实事物的行为数据==>一种特别的属性(属性值是函数)

## 对象创建方法

方法一：

Object构造函数创建：

语法`var p = new Object()`

**套路**：先创建一个空Object对象，再动态添加属性/方法。

**适用场景**：起始时不确定对象内部数据。

**问题**：语句太多。



方法二：

对象字面量模式创建：

语法：`var p = {name: '钱不二'}`

**套路**：使用{}创建对象，同时指定属性/方法

**适用常见**：起始时对象内部数据确定

**问题**：如果创建多个对象，有重复代码



方式三：

工厂模式创建：

语法：

`function createPerson(name, age) {`

​	var obj = {

​		name: name,

​		age: age,

​		setName: function(name) {

​		this.name = name;	

​		}	

​	}

​	return obj;

`}`

`var p1 = createPerson('Tom',12);`

**套路**：通过工厂函数动态返回对象。

**适用场景**：需要创建多个对象。

**问题**：对象没有一个具体的类型，都是Object的



方式四：

自定义构造函数模式：

语法：

` function Person(name, age) {` 

​	this.name = name;

​	this.age = age;

​	this.setName = function(name) {

​	this.name = name'

​	}

`}`

`var p1 = new Person('钱不二', 22);`



**套路**：自定义构造函数，通过new创建对象。

**适用场景**：需要创建多个类型确定的对象。

**问题**：每个对象都有相同的数据，浪费内存。



方式五（可以说是一个非常优秀的创建方式了）：

构造函数与原型的组合模式

语法：

` function Person(name, age) {` 

​	this.name = name;

​	this.age = age;

`}`

`Person.prototype.setName = function(name){  this.name = name;}`

`var p1 = new Person('钱不二', 22);`

**套路**：将共同方法放入原型对象中，其余属性丢进构造函数中初始化。

**适用常见**：需要创建多个类型确定的对象。





## 操作对象

方法一：利用.来操作 ==>对象.属性名

优点：编码简单

缺点：一些特殊情况不能用变量不能用





方法二：利用[]来操作==>对象['属性名']

优点：任何情况都能用

当属性名是变量，有特殊符号(-,/,...)等需要利用[]才能操作对象

对象[name];

# 问题

## 为啥要用对象啊？

同意管理数据

## 什么时候必须使用['属性名']的方式

1. 属性名包含特殊字符：- 空格
2. 属性名不确定

